I came up with a model for a new type of computer based only on logic that arises through how connections are either made or broken through time, from playing a game, Counter-Strike (a Half-Life mod) when it was in its original beta phase. The system was very poorly designed, like the accuracy system for the weapons was designed that if you slow down to a walk, your guns were more accurate, but they set the parameters up so that it triggered this extra accuracy just going the slightest speed under a full run. Using +moveup which was meant for swimming in the scripting language, which is the only "language" I used, you could get half way between a run and a walk for movement speed and get the accuracy of a walk and the silence of it, with movement sound being another similar flaw they made in the game. That combined with scripting firing of the gun so it briefly made you do +moveup before actually firing the gun and turning it off immediately after firing the gun effectively gave you a more accurate gun at a running speed. There were many holes in the original CS system, I repeatedly told them about them on their message board, getting repeatedly banned. I remind you: I only used the extremely simplistic scripting language built into the game, so I was exploiting and not cheating, even though in effect it was cheating. CS 1.6 should have been CS 2.0 because they made major changes to the engine due to what I was spreading around. At least one of the hacks that I kept to myself and did not put into my script still exist in the current CS system as far as I know. It was basic to the Quakeworld original engine Half-Life is based on. The script that is part of my work, for CS 1.6, has a fully automated taunt system for giving people a hard time. I built a randomizer and relational database that sometimes spits out a taunt based on the weapon or weapon type you are using just before your gun is actually fired when you fire, only using the one command, alias. Alias just lets you create or reassign a command to an indicated string of commands, and nothing else - basically, I can name (better fit than name: emulate) that tune in one note; with dynamic connections. I did not set out to do this, it just happened. I originally wanted a script to quickly buy weapons, and it developed from there. I have kept every beta and final released versions of the script from beginning to end, to show how it developed. 

I only claim to have proven this: A computable logic that arises from how connections are made and/or broken over time. That is a complete description of everything about this logic, and it is not mathematics. It is the simplest form of computable logic that we know of. I believe only using entanglement this could be one dimensional logic that only requires the dimension of time and constant input to operate. The models only use one command to perform logic, "alias" that only allows you to create a command or rewrite a created command to execute a string of commands. In my models that string only calls other alias created commands, basically looping all around itself only using connections. I have built if-thens, sophisticated do-whiles, a randomizer, a relational database and math emulators.

The simple calculator is easiest to understand, it works like an automated abacus - it is simple enough for a child to understand but is yet almost nonconceptual in how it works with its simplicity. If you see how it works here then you know everything about it, just not some of the methods of using it that I have developed: 

https://github.com/johnphantom/Dynamic-Stateless-Computer/blob/master/calculator_simple.cfg (pulls the text up online, nothing to download).

The problem people have when they understand how it works: it is not Turing Complete - it requires an "operator".

I propose the computer is the hologram and the hologram is the computer, where the computer is the fabric of space-time, only using entanglement - a "Dynamic Stateless Computer" that operates on "Logic Geometry" based only on connections, or links, or pointers - a much more simple computer than the three basic Boolean logic gates operating on mathematical binary bits that is every computer out there. The shape is the logic and the logic is the shape, sort of like a truth table that is dynamic where the "truths" change as it runs. 

Through the exercise of the most complex do-while I asked a question related to that, and the answer uses the ancient Chinese/Pascal's Triangle (which millions have looked at over thousands of years) in a new way: https://mathhelpforum.com/threads/combination-lock.17147/ I basically had to count nothing as something to count, as in you can have different items to count the permutations of but a default state of no item is possible for each, some or all to count in the permutations, and it doesn't seem anyone else in history was able to use the really basic mathematical concept of the Triangle in that way for the solution. It is similar to the 4 hats and 4 pegs question of how many permutations you can have that is commonly associated with Pascal's Triangle, but they did not count the empty pegs as part of the permutations that they can have. The technique of the implementation is a little interesting, with it being able to reach any of the 209 possible permutations of 4 wheels with 4 numbers (don't know if I should count 0, it is special in this case - if you do count 0, it is 5 numbers) in 4 keystrokes or less - it's how it scales that is the curiosity, where if I had 18 slots and 18 items to form a combination it would have almost 3x10 to 18th power or 2,968,971,264,021,448,999 possible permutations, each reachable within 18 keystrokes or less. slapaho5.cfg performs the permutations this problem illustrates. https://github.com/johnphantom/Dynamic-Stateless-Computer/blob/master/slapaho5.cfg

I don't have any idea as to how this would be physically built - none of the aspects of it, except for the dynamic logic that I also do not have any clue if it really is what I ask above. I just can do these things I demonstrate and in my extensive 50 years of digital computer experience I have not seen anything exactly like it, and I can find nothing online too.

Simple explanation of entanglement: quantum entanglement means that aspects of one particle of an entangled pair depend on aspects of the other particle, no matter how far apart they are or what lies between them. 

"Researchers at the forefront of quantum gravity have started to rethink space-time as a consequence of entanglement." https://www.yahoo.com/now/why-more-physicists-starting-think-045308127.html