I came up with a model for a new type of computer based only on logic that arises through how connections are either made or broken through time, from playing a game, Counter-Strike (a Half-Life mod) when it was in its original beta phase. The system was very poorly designed, like the accuracy system for the weapons was designed that if you slow down to a walk, your guns were more accurate, but they set the parameters up so that it triggered this extra accuracy just going the slightest speed under a full run. Using +moveup which was meant for swimming in the scripting language, which is the only "language" I used, you could get half way between a run and a walk for movement speed and get the accuracy of a walk and the silence of it, with movement sound being another similar flaw they made in the game. That combined with scripting firing of the gun so it briefly made you do +moveup before actually firing the gun and turning it off immediately after firing the gun effectively gave you a more accurate gun at a running speed. There were many holes in the original CS system, I repeatedly told them about them on their message board, getting repeatedly banned. I remind you: I only used the extremely simplistic scripting language built into the game, so I was exploiting and not cheating, even though in effect it was cheating. CS 1.6 should have been CS 2.0 because they made major changes to the engine due to what I was spreading around. At least one of the hacks that I kept to myself and did not put into my script still exist in the current CS system as far as I know. It was basic to the Quakeworld original engine Half-Life is based on. The script that is part of my work, for CS 1.6, has a fully automated taunt system for giving people a hard time. I built a randomizer and relational database that sometimes spits out a taunt based on the weapon or weapon type you are using just before your gun is actually fired when you fire, only using the one command, alias. Alias just lets you create or reassign a command to an indicated string of commands, and nothing else - basically, I can name (better fit than name: emulate) that tune in one note; with dynamic connections. I did not set out to do this, it just happened. I originally wanted a script to quickly buy weapons, and it developed from there. I have kept every beta and final released versions of the script from beginning to end, to show how it developed. 

I propose a "Dynamic Stateless Computer" that operates on "Logic Geometry" based only on connections, or links, or pointers - a much more simple computer than the three basic Boolean logic gates operating on mathematical binary bits that is every computer out there. The shape is the logic and the logic is the shape, sort of like a truth table that is dynamic where the "truths" change as it runs. 

Quantum mechanics is beyond me, but if this only needs connections, ie a quantum entanglement, can we build a computer that operates and does its entire run instantly? Like I said, all I need is connections to perform logic... no need for information... the shape is the logic. I understand some of quantum computers is instant, but sorting with Grover's Algorithm takes some time.

You are best off going to Github and seeing online without downloading the paper and models. When someone looked at my calculators, they accused me of: "You're not doing math! You're emulating math!" They were an afterthought to simply and clearly demonstrate this single concept. Look at the simple calculator and flowchart first, it only does addition and subtraction. Then look at the complex calculator that does multiplication and division.  As you well know, if I can do those things, I can do anything mathematically. In the main model I created if-thens, complex do-whiles, a randomizer and a relational database.

https://github.com/johnphantom/Dynamic-Stateless-Computer/blob/master/calculator_simple.cfg

https://github.com/johnphantom/Dynamic-Stateless-Computer/blob/master/calculator_simple%20Flowchart.png

Through the exercise of the most complex do-while I asked a question related to that, and the answer uses the ancient Chinese/Pascal's Triangle (which millions have looked at over thousands of years) in a new way: https://mathhelpforum.com/threads/combination-lock.17147/ I basically had to count nothing as something to count, as in you can have different items to count the permutations of but a default state of no item is possible for each, some or all to count in the permutations, and it doesn't seem anyone else in history was able to use the really basic mathematical concept of the Triangle in that way for the solution. It is similar to the 4 hats and 4 pegs question of how many permutations you can have that is commonly associated with Pascal's Triangle, but they did not count the empty pegs as part of the permutations that they can have. The technique of the implementation is a little interesting, with it being able to reach any of the 209 possible permutations of 4 wheels with 4 numbers (don't know if I should count 0, it is special in this case - if you do count 0, it is 5 numbers) in 4 keystrokes or less - it's how it scales that is the curiosity, where if I had 18 slots and 18 items to form a combination it would have almost 3x10 to 18th power or 2,968,971,264,021,448,999 possible permutations, each reachable within 18 keystrokes or less.

I don't have any idea as to how this would be physically built - none of the aspects of it, except for the dynamic logic that I also do not have any clue if it really is what I ask above. I just can do these things I demonstrate and in my extensive almost 50 years of digital computer experience I have not seen anything exactly like it.

Maybe you wonder about my computer experience? I have always been fascinated by computers, starting in 1972 using a prototype Cogar 4 that my dad got his hands on, when I was 3. By the time I was 5, Singer wanted to use me in a commercial to sell the computer, because if a 5 yo could start it, load the OS and then load games, that proved anyone could. My first mentor helped develop Ethernet after working for my father, and allowed me to hold one of the first breadboard ethernet cards developed when I was 10 telling me, "This is the future." My first real program (programming since at least 5 if you count the Cogar ASM I had to type to get to the OS and games) was in BASIC when I was 11 that I learned from a manual without anything more than a small example for each command, written with pencil on paper; a rudimentary AI demonstration called "Animals". Second program I made I had another computer (we had moved and left the one at my dads company behind when he sold it) and was a dot bouncing around the screen. Third program, with 12 year old's understanding of math, I attempted to do 3D. I first professionally programmed in 1982, started building computers and networks for a small computer company in 1986 owned by my second mentor, Peter De Blanc who lead ICANN for a period, was an official beta tester and developer for OS/2 2.0 and developed a device driver for it for the extremely complex Truevision Targa+ 64 video editing board (pic: https://imgur.com/a/hMe21Qe ) directly flipping bits on it in 1991. The code for the model for the dynamic stateless computer is about 640 lines and took me 6 months to complete, with the code for the Targa+ device driver being over 4200 lines and took me one 20 hour sitting that compiled and ran the first time that I have 3 witnesses for. That's almost 30 years ago. My experience has only gone up from there. This dynamic logic is something I found, that I have never seen anything like even searching for it on the Internet for the past 20 years.
